"""
1차
풀이 시간 : 2시간 + @
시도 횟수 : 4회
실행 시간 : 448ms
메모리 : 121416kb

2차
풀이 시간 : 51분
시도 횟수 : 3회
실행 시간 : 656ms
메모리 : 130144 kb

- 실수 모음
    - 설계 실패(25~ 40이 공동 visited 관리인 것 놓침)
    - 룩업테이블 실수
    - 설계 디테일 놓침(30이 두개인 것!!)

Routine
1. 문제 그냥 정독 ok
2. 문제 주석 복사 ok
4. 테스트케이스 외에 고려해야할 사항 생각해보기 + 설계에 반영
    : 25부터 공통 visited인것, 40도 공통인 것 생각하기 !!
5. 종이에 손설계 : ok
6. 주석으로 구현할 영역 정리 : ok
7. 구현 : ok
8.테스트케이스 단계별 디버깅 확인 : 테스트케이스 단계별이 어려운 문제라 디버거 주로 활용함
9. 1시간 지났는데 디버깅 헤매는 중이면 리셋!!

"""

"""
========================== 2차 코드 리뷰 ==============================
0825 문제 읽기+ 주석 정리 

0831 설계
    예전 풀이 말고 공동으로 visited를 관리해야하는 칸의 관리를 쉽게 하기 위한 방식으로 visited 구현하자! 
    점수 룩업테이블 vistied idx 룩업테이블 만들자 ! 
    10, 20, 30이 유일하니까 그냥 in 사용해서 빨간화살표 가는 경우 처리하자(여기서 실수..! ) 

2045 구현시작

2056 구현완료 디버깅 시작 
    수업시작 4분 남았다 서둘러!!!!!!!!!!!!!!!!!!!11 
    이전에 있던 visited 체크 해제 안한 것 발견해서 해제함
1250 
    수업시작해서 접고 점심시간에 다시 디버깅1! 
    자꾸 더 큰 숫자 나오길래, selected랑 그 때 더한 숫자 dfs에 매개변수 추가해서 현황 보고 
    그 때를 브레이크 포인트로 잡아서 왜 가지 말아야할 곳을 가는지 체크 
    visited가 체크 돼있는데 가길래 바로 룩업테이블 체크 
    수정 후 제출했는데 또 오답. 같은 방식으로 돌아보니 또 같은 현상
    룩업테이블 전반적으로 점검=> 틀린 부분 고치고 제출해서 정답
    
- 총평
    시간 효율은 전보다 덜했지만 그래도 구현 난이도가 훨씬 쉬운 방법을 택해서 구현에 성공했다.
    한번 오답이 돼서 틀린 부분이 있다면, 특히 룩업테이블 같은 것들은 전반적으로 다 점검하고 제출하는 습관이 매우 필요 ;

"""
"""
 윷을 던질 수 있는 횟수는 10  각 횟수마다 나오는 이동 칸 수도 정해져 있습니다.

계산을 하여 주어진 이동 횟수에 나갈 말의 종류를 잘 조합하여 얻을 수 있는 점수의 최댓값을 얻고자

처음에는 시작 칸에 말 4개
말은 게임판에 그려진 화살표를 따라서만 이동할 수 있습니다

 파란색 칸에서 이동을 시작한다면 빨간색 화살표를 타야되고,
 이동하는 도중이거나 파란색 칸이 아닌 곳에서 이동을 시작하면 검은색 화살표를 따라서 가야합니다

 말이 도착 칸으로 이동하면 남은 이동 횟수와 관계 없이 이동을 마칩니다.

 게임은 10개의 턴으로 이뤄지고 도착칸에 도착하지 않은 말을 골라
 원하는 이동횟수만큼 이동할 수 있습니다.

 시작칸과 도착칸을 제외하고는 칸에 말들을 겹쳐서 올릴 수 없습니다.
 특정 말을 움직였을 때 도달하게 되는 위치에 다른 말이 이미 있다면,
 이는 불가능한 이동임을 의미

 10개의 이동할 수 있는 칸 수가 순서대로 주어질 때 얻을 수 있는 점수의 최댓값
"""


# dfs 구현
def dfs(level, finish_lst, score, cur_lst):
    # print(f"==============level : {level}==================")
    # print(finish_lst)
    # print(cur_lst)
    # print(visited)
    # print("score :", score)
    global answer
    if level == 10:
        answer = max(answer, score)
        return

    for i in range(4): #4개의 말 중 하나 선택
        if finish_lst[i]: continue #이미 도착한 말 선택 ㄴㄴ

        tmp_finish = finish_lst[:]
        tmp_cur = cur_lst[:]

        r, c = cur_lst[i]
        before_vi = idx_arr[r][c]
        if score_arr[r][c] in(10, 20, 30) and r==0:
            r = score_arr[r][c]//10
            c = lst[level]-1
        else:
            c += lst[level]

        if c >= len(score_arr[r])-1: #도착이면
            tmp_finish[i] =1
            c = len(score_arr[r])-1

        vi = idx_arr[r][c]
        # print(vi)

        if not tmp_finish[i] and visited[vi]: continue #말 있으면 안간다
        visited[vi] = 1
        visited[before_vi] = 0
        tmp_cur[i] = [r, c]
        dfs(level+1, tmp_finish, score+score_arr[r][c], tmp_cur)
        visited[vi] = 0
        visited[before_vi] = 1


#배열 준비
score_arr =[
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 0],
    [13, 16, 19, 25, 30, 35, 40, 0],
    [22, 24, 25, 30, 35, 40, 0],
    [28, 27, 26, 25, 30, 35, 40, 0]
]

idx_arr = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 33],
    [21, 22, 23, 24, 25, 26, 20, 33],
    [27, 28, 24, 25, 26, 20, 33],
    [29, 30, 31, 24, 25, 26, 20, 33]
]

visited = [0]*34
finish_lst = [0]*4
cur_lst = [(0,0), (0,0), (0,0), (0,0)]
answer = 0

lst = list(map(int, input().split()))

#dfs 실행
dfs(0, finish_lst, 0, cur_lst)
#출력
# print('-------------')
print(answer)

"""
코드리뷰 ...............

내가 이런 유형에 엄청 취약하구나 ....................................

- 본 연습에서 1시간 풀고 확실히 객관적으로 이 문제가 더 쉽지만 내가 취약함을 느낌
- 1시간동안 문제 이해+구현+디버깅하다가 빈틈을 너무 못잡고 있음을 느껴서 강의실 밖으로 나가서
    코드 뒤집어 엎기 / 지금 코드 디버깅으로 밀고 나가기 / 다음 문제 넘어가기 중 어떤게 적합할지 고민
- 현재 코테가 틀린 이유를 전혀 파악하지 못하고 있음 + 유형 취약 + 다음 문제가 훨씬 내가 잘하는 유형이라 판단
- 10분만 추가 디버깅햅고 추가 가닥 안잡히면 다음 문제 넘어가기로 선택 => 굿초이스

첫 구상 아이디어 !
더하는 점수칸이 나의 말판이 되어 내 숫자가 몇인지 보고 어느 위치인지 가늠해보자 ?
파란색 화살표로 가는 경우는 10 / 20 / 30일 때밖에 없으므로
이동하기 전에 내가 10, 20, 30인지를 확인하고(화살표를 탈지 확인하고)

맞으면 파란색 라인으로 숫자를 더해주자 (이 때 더할 숫자가 규칙성 없이 중구난방이므로 ! 이 부분 배열로 저장)
그래서 네 개의 말이 현재 놓인 말의 점수를 표현하는 now배열, 파란색 화살표를 탔는지 확인하는 flag 배열,
최종 도착했는지를 확인하는 finished 배열을 활용하고자 함.

주의점
같은 점수인 칸이 있다 어떻게 처리할까? flag가 0인지 아닌지로 구분 가능(ex. 30, 22)

위 방법으로 구현하면서 어려움을 겪은 점
- 40일 때의 처리. 딱 40이면 점수 40을 얻고, 그보다 넘어가면 점수를 얻지 않고 finished만 처리해야함
    => 이부분 자꾸 틀리고 디버깅 오래걸렸음..
- 이미 말이 있는 위치를 처리하기가 어려웠음. !!
- 다시 풀면서 깨달은 40은 한 곳에서 모임+화살표를 타도 25에서 한곳에 모임 => 따라서 해당 칸에 말 있는지 확인 함께 해야함을 간과

================================RESET======================================

다시 시간재고 풀기........................

영상에 시작시간이 안보임; 그냥 시작한지 몇분 단위인지로 적겠다 ...

0분 ~ 12분  문제읽기 / 구상 / 설계
            - 기존에 했던 방식과 다른 새로운 기막힌 방법이!!!!!!!!!!!!!생각안남!
            - 하던대로 ! 하기로 함! 구현 불가한 것 아니라고 생각듦. 다만 실수의 여지가 많다;
            - 기존에 점수를 가지고 중복 체크하던 방식이 꽤나 어려웠어서 이번엔 점수판 배열을 만들기로 함
            - 화살표를 각각 어디로 타냐에 따라 도착까지 이동하는 칸 수가 달라지므로 이를 나타내는 인덱스 배열 두자1
            - now, flag, finished는 기존 방식 활용하고 dfs로 돌 때 복사해서 가지고 다니자
13분~ 2시간  구현! 구현! 디버깅! 구현.. (시간 나누는 거 잘 못함... 어떻게든 구현하고 싶은 마음에 급급했ㄷ음 )
        - 자꾸 엉뚱한 겁나 뜬금없는 숫자가 나온다? 왜지 ?
            visited 체크 해제 문제라고 생각해서 요리조리 해제해보고 체크해보고 난리브루스치며 디버거 사용해서 visited확인함
            => visited가 해제 안돼서 점수가 엄청 낮게 나오거나
            => return 한 순간에 다 해제해버려서 너무 높게 나오거나 의 문제였음
            => 요리조리 돌고 돌다 dfs 내에서 이렇게 다양한 상황에 visited 관리가 어려움을 느끼고 복사해서 들고다니기로 결정!
        - 그래도 큰 숫자가 나온다?
            - return 부분에 그 큰숫자 이상일 때만 selected를 뽑았다
            - 그리고 그 selected로 손으로 테케 따라가보기
            - 파란색 화살표를 타는 순간에 ! visited를 잡지 못하는 것 발견
            - flag가 변경되는 시점이 헷갈렸다
            => flag를 변경시키되, 직전 flag를 기억해두고 해제할 때 활용하는 식으로 수정
        - 이제 테케가 거의 다 맞는데 예제 입력 3이 혼자 안맞는다 죽겟다 아이고
            - 마찬가지로 조건문으로 218이 출력될 때의 selected 출력 후, break point 걸어서 디버깅
            - 40을 가지 말아야할 때(거기에 말이 있을때) 마지막에 자꾸 방문하는 문제 발견
            - 그러다 유레카! 40은 0~3 flag모두가 만나는 곳이잖아? visited 일괄 처리해야지 ~
                => 수정해서 테케 맞음 제출!!
        - 얄짤없이 틀렸습니다 ~!
            - 원인 모르겠다 고민곰니고민고민 ..
        - 일단 킵 ................... 다른 문제 풀러 감

    그리고 다음날 ................
- 다시 풀어보자 !!!!!!!!!!!!1
- 25도 파란색 화살표 탄 애들은 한 곳에서 만남 발견 ;
- 어떻게 코드를 대폭 수정할지 고민 => 40 처리한 것처럼 flag가 0인지 아닌지 + 25 넘겼는지 조건분기문으로 처리하자
- flag 1, 2, 3이 각각 25를 몇번째에서 만나는지를 lst로 미리 저장하고
    이걸 이용해서 flag 이면서 이 시작 index를 넘겼는지로 25이후라서 visited한번에 처리할지 말지를 결정
    => 처리했는데 테케3 또 안잡힘. 또 218 나옴 ? 왜 ?
    => 40일 때를 먼저 처리하니까 됐음... 그렇다면 25 이후 코드에 40일 때 처리 필요없겠군?
        flag를 안 탈때는 해당 분기를 통과 못해서 그랬음을 깨달음, ,
- 정답 .........................................

피드백
- 잘한 점
    하나의 아이디어만 생각난다면 어떻게든 꾸역꾸역 구현하기 ...
- 못한 점
    문제의 빈틈을 빠르게 캐치하지 못함!!!!!!!!!!!!!11 이 문제의 핵심은 파란길로 가기+25부터 또 만나기+40에서도 만나기!
    시간관리 미흡 .. 따로 리셋해서 새로 풀기도 했고,, 약간 시간 관리하며 구현보다는 어떻게든 내 아이디어를 구현으로 뚫어내기에 급급했음 ㅠ
    아이디어 취약.......... => 이 문제 만큼은 다른사람들 코드 5개 이상 봐야겠다 ....
    내가 아이디어가 취약하다면???????????? 여러 아이디어를 보고 생각의 갈래를 더 열기!!!!!!!!!!!!!!!!!11

    코드리뷰 후 나의 디버깅 실패요인은 윷놀이 판을 배열로 구현하려고 한게 아니라
    말 위치나 visited를 어려운 방식으로 관리한 데에 있음을 깨달음 ; 더 심플하게 더 간편하게 사고하려는 노력 필요하다

=============================다른사람들 코드리뷰하기=========================
1. hyem4900
    - 아이디어
        배열에 가지 말아야할 곳은 0. 칸은 점수로 그림 속 map을 그대로 구현함
        이동할 방향도 같은 크기의 arr로 방향벡터 찾을 수 있도록 준비
        visited(used)도 같은크기인걸 3차원으로 4개 준비 (이유는?)
    - 피드백
        가지치기를 했다. 나는 이런 최댓값 구하는 문제에서 가지치기가 서툰편인데,
        얻을 수 있는 가장 높은 점수인 40점을 남은 횟수에서 다 얻어도 현재의 최댓값을 넘지못하면 종료시키는 방식 => 리팩토링에서 적용해보자!!

        arr로 윷놀이 판을 그대로 표현한 점이 매우 직관적 => 디버깅도 편할듯
        내 기존 방식은 디버깅이 매우 어려운 방식. 말이 현재 어느 위치에 있는지 now, flag 값들을 보고 두세번 꼬아서 생각해야한다;
        이런 직관적인 방식으로 생각하려고 노력해보자 ..!

        used 를 꼭 3차원으로 해야했나? 어차피 하나의 판 안에서 움직이면 mal 별로 used를 따로 두지 말고
        used 안에 말 번호를 넣음으로써 관리할 수 있었을 것

2. lg960214
    - 아이디어
        클래스를 활용한 연결리스트 구현
        2~40까지 노드 연결하고 파란색을 진짜 'b'로 파란색으로 표현.
            문제 보자마자 자바로 풀었다면 클래스 + 연결리스트 구현으로 했을 것 같다고 생각했는데,
            파이썬 클래스 구현력이 떨어졌던게 아쉽.. 내가 하고 싶었던 풀이이면서도 이해가 어렵 ㅠ
        코드 이해;
            1. 클래스 선언
            2. 시작 노드 선언하고 2~40노드까지 red_arrow에 넣어서 연결!!
            3. blue_node인 10, 20 30을 기억해뒀다가 ! 그 노드 다음에 또 그 다음 노드들을 생성해서 연결
            4. 25는 파란길이 모이는 공동 노드이므로 만들어뒀다가 10, 20, 30의 끝에 25를 넣어두고!
                25에 남은 노드들을 연결(마지막은 처음에 만들어둔 40연결하고 goal 연결! 같은 노드니까 꼭 만들어둔 객체 넣음)
            5. 게임 상태를 저장하는 객체로 bfs돌기 (cur_progress에 각 4개의 말이 있는 위치노드가 있음)
                현재 판의 노드 중 원하는 말을 이동시키고 게임 상태 update한거 queue에 넣어서 반복하는 방식
                move : 재귀로 pointer를 step만큼 이동시키고 ! 그 위치가 target내의 현재의 말이랑 같은게 있는지 확인. 없으면 이동


        피드백
            bfs 가지치기 신기했다. dfs로 구현하며 맨 처음, 네 말 중 어떤 말을 움직여도 사실 숫자 번호만 다를 뿐
            같은 상황이라는 생각이 들었으나 개선할 방법 생각 안나서 걍 했었다. 그 점을 센스있게 잘 잡은 것 같다 !

            클래스 어렵다. 연결리스트로 구현하고 싶었으나 나는 구현력 부족해서 안됐던걸 해내심.
            하지만 아직 파이썬 클래스 배워서 활용하고 싶은 욕구는 안든다.. 파이썬은 클래스 아닌게 더 편하다 난 ,,

            Node 클래스에서 red_arrow와 blue_arrow가 list가 아니라 그냥 Node 객체로 저장해도 되지 않을까? (다음것 하나만 저장하니까!)
            (for문만으로 해결하려고 한걸까? if문 안쓰고? )
3. rlaehdgus95
    - 아이디어
        나랑 비슷하다 ! 내 첫 구현시도와 두번째 구현을 합쳐놓은 느낌
        하지만 나보다 훨씬 간편하게 말 관리를 한듯하다(튜플로 행 열 표기 느낌으로!! 좋댜 ... )
        난 배열을 flag, now로 두개나 했고 하다가 나도 헷갈림.
        윷놀이 판을 행렬로 표현한 만큼, 좌표처럼 구현했다면 더 나았을지도 ..! (는 핑계고 내 구현력 부족)
        used를 1차원으로 간편하게 표현 ..!..
    - 피드백
        가지치기 굿(혜민님과 동일)
        used 처리 방식이 신기하다. 오오 .점수로 하면 겹치니까 딱 그 때의 used 번호를 미리 지정해놓음 굿!
        => 이 방법을 바로 적용했다면 하드코딩 적었을 것. .. 내가 활용해볼 만한 방법인듯

4. princeofcoding : 66줄이요? ;;;;
    - 아이디어
        val : 점수배열 (arr의 값이 index가 되어 점수 찾아옴)
        arr로 배열 하나를 노드처럼 사용하고 갈림길이 있을 때만 갈림길로 원소 2개
        원소 2개일 때 출발하려면 다음 노드로 cur값을 넘기는 방식.
    - 피드백
        아이디어가 나랑 비슷한듯 하면서 내가 now로 관리하며 어려움을 겪었던 이동한 칸 수!를 깔끔하게 구상

        아이디어가 좋으니 구현이 간편해진다
        같은 노드에 방문했는지 여부가 나는 visited가 겹쳐서 4행을 모두 확인했다면 고유의 index로만  확인해도 돼서
        훨씬 쉽다

5. kimgs8882005
    - 아이디어
        윷놀이 판 구현은 나랑 비슷한데 행으로 구분 x 독립적 배열로 관리
        말 관리는 동현님과 비슷
        visited 체크는 mal_lst[i]를 활용한듯!
    - 피드백
        윷놀이 함수명 .... 음..
        visited체크 어떻게 했는지 이해가 어려웠다. 사실 아직도 잘 이해 안됨 ,


"""

def dfs(level, score, now, flag, finished, selected, visited):
    global answer
    if level == 10:
        answer = max(answer, score)
        return

    num = arr[level]
    for i in range(4):
        if finished[i]:
            continue

        # 배열 복사 for dfs
        tmp_now = now[:]
        tmp_flag = flag[:]
        tmp_finished = finished[:]
        tmp_visited = [[] for _ in range(4)]
        for k in range(4):
            tmp_visited[k] = visited[k][:]

        # 다음 이동할 지점과 이전 flag 기억!!!!
        next = tmp_now[i] + num
        bf = tmp_flag[i]

        # 파란색 탄 적 없고 다음 이동할 칸이 파란색 화살표 따라가면
        # flag를 해당 화살표로 변경해준다
        if not flag[i]:
            if next > 0 and next % 5 == 0 and next // 5 < 4:
                tmp_flag[i] = next // 5

        # 이전 말 위치 해지하기(동시에 만나는 곳이라면 visited 일괄 관리)
        if tmp_now[i] == len_lst[tmp_flag[i]] - 1:
            for k in range(4):
                tmp_visited[k][len_lst[k] - 1] = 0
        elif tmp_flag[i] and tmp_now[i] >= flag_meet_timing[tmp_flag[i]]:
            go_after_25 = tmp_now[i] - flag_meet_timing[tmp_flag[i]]
            for k in range(1, 4):
                tmp_visited[k][flag_meet_timing[k]+go_after_25] = 0
        else:
            tmp_visited[bf][tmp_now[i]] = 0

        # 이동할 위치가 40을 넘어가면
        if next >= len_lst[tmp_flag[i]]:
            # 말 현재지점으로 옮기고 종료했다는 것 표시하고 다음 말 옮기러 가기
            tmp_now[i] = len_lst[tmp_flag[i]]
            tmp_finished[i] = 1
            dfs(level + 1, score, tmp_now, tmp_flag, tmp_finished, selected + [i], tmp_visited)
            continue

        # 말 next 위치로 옮길 수 있는지 체크
        # 파란색 따라가면 그 flag에서 본다
        if tmp_visited[tmp_flag[i]][next]:
            continue


        # 다음 칸이 파란선을 타면서 25 이후이면
        if next == len_lst[tmp_flag[i]] - 1:  # 40 일 때
            for k in range(4):
                tmp_visited[k][len_lst[k] - 1] = i + 1
        elif tmp_flag[i] and next >= flag_meet_timing[tmp_flag[i]]:
            go_after_25 = next-flag_meet_timing[tmp_flag[i]]
            for k in range(1, 4):
                st_point_by_flag = flag_meet_timing[k]
                tmp_visited[k][go_after_25+st_point_by_flag] = i + 1
            if next == len_lst[tmp_flag[i]] -1:
                visited[0][20] = i+1
        else:
            tmp_visited[tmp_flag[i]][next] = i + 1  # 파란색따라가면 파란색 쪽으로 체크해준다

        tmp_now[i] = next
        plus = score_arr[tmp_flag[i]][tmp_now[i]]
        dfs(level + 1, score + plus, tmp_now, tmp_flag, tmp_finished, selected + [i], tmp_visited)


score_arr = [
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 0],
    [0, 2, 4, 6, 8, 10, 13, 16, 19, 25, 30, 35, 40, 0],
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 25, 30, 35, 40, 0],
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 28, 27, 26, 25, 30, 35, 40, 0]

]

len_lst = [21, 13, 17, 23]
flag_meet_timing = [0, 9, 13, 19]
finished = [0] * 4
visited = [[0] * 24 for _ in range(4)]  # 0 출발점 끝점 len_lst[i]
flag = [0] * 4
now = [0] * 4
arr = list(map(int, input().split()))
answer = 0
dfs(0, 0, now, flag, finished, [], visited)
print(answer)
